<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
        <head>
                <meta http-equiv="Content-type" content="text/html;charset=UTF-8"/>
                <title>Notas de Manuel Gómez sobre CI3725 - Inicio</title>
                <style type="text/css">p { text-align:justify; }</style>
        </head>

        <body>
                <h1><a href="index.html">Notas de Manuel Gómez sobre CI3725</a></h1>
                <hr/>
                <h2>2011-09-20 (semana 1): Inicio</h2>
                <p>En la primera clase práctica hablamos sobre expresiones regulares.  Les dije que las expresiones regulares POSIX no hacen cosas como back-references, pero esto es falso.  Las expresiones regulares extendidas definidas por POSIX sí soportan back-references.  Oops.  En cualquier caso las expresiones "regulares" con back-references se usan primordialmente para describir lenguajes que no son regulares, y eso no se hará en este curso.  La descripción de lenguajes libres de contexto se hará usando gramáticas libres de contexto, y se reconocerán sus elementos generando autómatas de pila a partir de esas gramáticas.  Para entender un poco mejor lo que implica usar back-references hay que entrar en ciertos asuntos que se tratarán en la teoría como a la mitad del curso.  Quienes estén ansiosos por entender todo este asunto deberían leer <a href="http://swtch.com/~rsc/regexp/regexp1.html">este artículo</a> sobre la eficiencia de varias implementaciones de expresiones regulares y las consecuencias del uso de back-references.</p>
                <p>Hay ciertos problemas en cuanto a posibles ambigüedades en el significado de algunas de las cosas que especifica el standard de POSIX con respecto a expresiones regulares.  La parte relevante del standard POSIX está <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html">acá</a> y <a href="http://standards.ieee.org/findstds/interps/1003-2-92_int/index.html">acá</a> hay algunas aclaratorias sobre partes relevantes de este y otros documentos relacionados.  No es un documento que deban leer o que les vaya a ayudar en la materia, pero si les interesa el tema, ahí pueden descubrir cosas interesantes.  Además que leer documentos de standards como este es la mejor lección sobre documentación que puede tomar un computista.  Otros standards interesantes son los de C y C++, pero esos son extremadamente complejos y extensos.  Si se lanzan a echarle un ojo a documentos como esos van a descubrir que mucho de lo que creían saber estaba errado y que no saben casi nada de lenguajes y sistemas que creían dominar.   Esto es algo bueno: estar conscientes de nuestra propia ignorancia es la mejor manera de evitar que nos joda cuando menos lo esperamos.  Tengo varios documentos de este tipo en mi computadora; si están interesados, búsquenme en la universidad y se los paso.  El resto del standard POSIX a cuya sección de expresiones regulares referí lo pueden ver <a href="http://pubs.opengroup.org/onlinepubs/9699919799/">acá</a>.  Pero insisto: estas vainas tienen una relación apenas tangencial con el curso y no son de ninguna manera necesarias, y si tienen tiempo libre, recomiendo que se pongan a aprender C++.</p>
                <p>Como les dije en clase y por Twitter, de todos los que me he encontrado en internet, <a href="http://www.regular-expressions.info/">esta página</a> tiene uno de los tutoriales de expresiones regulares que mejor equilibran completitud y comprensibilidad sin sacrificar correctidud.  Hay unas cuantas recomendaciones ahí para un editor que incluye expresiones regulares, pero no le hagan caso a nada de eso.  Si están en un sistema operativo con alguna relación con Unix entonces seguramente ya tienen un montón de herramientas instaladas con las que pueden usar expresiones regulares como es debido; este es el caso de Linux y estoy casi seguro de que también es así en OS X.  En OS X deberían investigar sobre algo llamado <a href="http://www.macports.org/">MacPorts</a>.  En Linux deben usar el manejador de paquetes de su distribución para instalar los paquetes relevantes.  En cualquiera de los dos casos es muy probable que sus sistemas ya incluyan implementaciones de ed, grep, sed, ex, vi, perl y quizás hasta vim y un shell que pueda utilizar expresiones regulares directamente.  Ubuntu incluye por defecto una versión recortada de vim que no sirve ni de juguete; si usan Ubuntu y quieren jugar con expresiones regulares en vim, lo primero que tienen que hacer es instalar los paquetes llamados "vim" y "vim-doc", y luego deberían echarle un ojo a "/etc/vim/vimrc" que trae un montón de vainas útiles comentadas por defecto.  Por desgracia tengo tiempo sin tener la oportunidad de jugar con otras distribuciones así que no sé qué tal serán las demás en este sentido.</p>
                <p>Si usan Windows, lo mejor que pueden hacer es parar e instalar un sistema operativo decente.  Son computistas.  Los estudiantes universitarios de química no juegan con plastilina y colorante de torta en sus laboratorios, y los de ingeniería mecánica no juegan con LEGOs.  Ustedes no deberían usar sistemas operativos de juguete cuando se trate de trabajar y no de jugar.  Dicho eso, si les resulta insuperable su mediocridad y sus ganas de sufrir y hacer las cosas de la manera más pirata posible, existen soluciones que les permitirán usar herramientas de un Unix decente a pesar de que su sistema operativo sea un asco.  Va a ser lento, va a ser limitado y va a hacer que aprendan mal y luego tengan que hacer más esfuerzo para corregir los errores y las malas prácticas que obtendrán por no hacer las vainas bien en vez de piratear su camino por el aprendizaje de herramientas fundamentales de Unix.  Pero si eso es lo que quieren hacer, existe <a href="http://www.cygwin.com/">esta opción</a> que es en sí algo bastante bien hecho aunque como concepto sea una cagada al lado de simplemente usar un sistema operativo que haga todo eso.  Ocupa muchísimo espacio en disco y es lento, pero bueno, allá ustedes si deciden usar eso.  La otra opción es que trabajen en máquinas del LDC, pero eso los obliga a estar allá, o a trabajar remotamente que no debe ser muy agradable considerando la calidad de los servicios caseros de conexión a Internet en este país.  Hay gente que considera una opción viable usar virtualización para ejecutar un sistema operativo decente sobre uno inútil y así no tener que quitar el inútil para usar el decente.  Enumerar las razones por las que eso es una grandísima estupidez queda como ejercicio para el lector.</p>
                <p>C++ es un tema complicado.  Si al fin se decide de forma definitiva que va a ser el lenguaje a usar para los proyectos, quisiera dar varias clases prácticas completas sobre asuntos del lenguaje.  Es un lenguaje extremadamente complejo que muy poca gente comprende a profundidad.  De esto hay mucho que decir, y no quisiera hablar mucho sobre el asunto hasta que sea definitivo que lo usaremos.  Yo conozco C++ bastante bien en términos relativos a lo que la mayoría de la gente que piensa que conoce C++ realmente sabe del lenguaje, pero por eso mismo lo conozco suficientemente bien para saber que mi conocimiento del lenguaje apenas raspa la superficie del universo de complejidad de ese monstruo.  Me agrada bastante y disfruto caerme a coñazos con él, así que si llega a decidirse de forma definitiva que ese va a ser el lenguaje que usemos en el curso, serán gratamente bienvenidas todas las consultas y llamadas de auxilio que tengan que ver con C++.  Que no les dé pena!  En su momento les daré sugerencias de cómo aprender lo que necesiten de él y cómo evitar lo que no necesiten, que es tanto o más importante que lo primero.  Una cosa sí es muy importante: no cometan el error de asumir que porque saben un poco de C entonces C++ será sencillo.  C y C++ están emparentados y casi todo C es compatible con casi todo C++, pero en realidad son lenguajes completamente diferentes.  Si se limitan a programar como si estuvieran usando C, o si simplemente deciden usar C, quizás su experiencia previa pueda serles útil.  El problema con eso es que la naturaleza del problema que se va a resolver en el laboratorio de este curso es bastante adaptable a muchas cosas que C++ hace y C no; es decir, si se meten con cosas de C++, en principio se les simplificará mucho la vida.  El problema es que en C++ es bastante difícil, si no imposible, aprender sobre unas partes del lenguaje sin tener que aprender un poco de todo.  Pero bueno, ya les contaré.  Haré lo posible por que se determine más temprano que tarde en forma definitiva qué lenguaje(s) se usará(n) para el laboratorio y así poder comenzar a hablar de esto en profundidad.</p>
                <p>No es que quiera asustarlos, pero quiero asustarlos.  Traductores es de lejos la materia obligatoria más difícil de la carrera y es mucho más difícil que casi todas las electivas.  Para la mayor parte de los computistas, que eligen electivas suaves, Traductores es el punto de mayor dificultad de toda la carrera, y en muchos de esos casos el proyecto del laboratorio podría llegar a ser el código más complejo con el que trabajen en sus vidas, dependiendo de cómo sea el ejercicio de sus carreras.  Tienen que empezar a trabajar ahora mismo, así no sepan ni siquiera en qué lenguaje se va a hacer el proyecto.  Vayan investigando sobre Flex y Bison.  Busquen material de estudio donde puedan.  Las páginas de los profesores <a href="http://ldc.usb.ve/~emhn/">Novich</a> y <a href="http://ldc.usb.ve/~astorga/">Astorga</a> tienen bastante material que les va a servir a lo largo de todo el curso.  Hace unos días escribí unos pequeños scripts en Bash que descargan de esas dos páginas un montón de materiales relacionados con el curso.  Son horribles, pero es porque la intención era que cupieran en uno o dos Tweets.  No pierdan su tiempo intentando descifrarlos.  Tengo entendido que la de Ascander también tiene materiales útiles para Traductores, pero nunca la he visto.  Acá les dejo una versión combinada de los scripts que mencioné:</p>
                <blockquote><p>(e=emhn;w=wget;q=$w\ -O-;z=ci3725;r=ldc.usb.ve/;x=$r~$e/cursos/;a=astorga;y=$r~$a;$q $x|sed -n "s%.*\($z/[0-9]\{6\}\).*%$x\1%p"|xargs $w -rk -np -nH --cut-dirs=2;cd $z&amp;&amp;{ mkdir $e&amp;&amp;mv * $e;mkdir $a&amp;&amp;cd $a&amp;&amp;$q $y|sed -n $'670d\n618,705s%.*f="\\([^"]*\\).*%'$y/\\1%p|xargs $w;})</p></blockquote>
                <p>Como esto es un documento HTML, los caracteres ampersand (&amp;) en ese script debieron ser escapados (convertidos a "&amp;amp;") para poder incluirlos acá.  Pueden copiar ese texto y ejecutarlo en una cónsola en Linux que esté corriendo Bash.  Creará un directorio llamado "ci3725" en el directorio donde lo ejecuten, y ahí guardará varias cosas que descargará de las páginas de los profesores Novich y Astorga.</p>
                <p>Ya saben que cuando necesiten cualquier cosa me pueden ladillar por cualquiera de los medios de contacto que les mencioné en clase, y si no me buscan en sala; es bastante probable conseguirme ahí.  Por si acaso, mi usuario en <a href="https://twitter.com/mgomezch">Twitter</a> y en <a href="http://identi.ca/mgomezch">identi.ca</a> es mgomezch, y el nombre de mi cuenta de Gmail es targen.  Suerte.  Échenle bola.</p>
                <hr/>
                <p>
                        <a href="http://validator.w3.org/check?uri=referer">
                                <img src="http://www.w3.org/Icons/valid-xhtml11" alt="Valid XHTML 1.1" height="31" width="88"/>
                        </a>
                </p>
                <p>Y lo escribí a mano en Vim sin más referencia que las primeras 4 líneas del boilerplate.</p>
                <p>Like a boss.</p>
        </body>
</html>
