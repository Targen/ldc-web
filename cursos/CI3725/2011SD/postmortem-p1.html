<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
        <head>
                <meta http-equiv="Content-type" content="text/html;charset=UTF-8"/>
                <title>Notas de Manuel Gómez sobre CI3725 - Proyecto 1, post mortem</title>
                <style type="text/css">p { text-align:justify; }</style>
        </head>

        <body>
                <h1><a href="index.html">Notas de Manuel Gómez sobre CI3725</a></h1>
                <hr/>
                <h2>2011-10-31 (semana 7): Proyecto 1, post mortem</h2>
                <p>Felicito a todos los estudiantes que le echaron bola con el proyecto por sus esfuerzos.  Sé que les costó mucho trabajo, quizás más de lo que suelen esperar de un proyecto que valga apenas 10% de la nota de una materia de la carrera, y se aprecia su esfuerzo.  Personalmente vi como muchos de ustedes comenzaron a trabajar muy poco tiempo después de la publicación del enunciado, y entiendo perfectamente lo que eso significa: que se lo tomaron muy en serio.  Conozco perfectamente, igual que cualquiera de ustedes, la manera de trabajar en nuestra carrera: haces todos los proyectos a última hora, pero eso no significa que no sepamos organizar nuestro tiempo ni que seamos irresponsables, sino que en todo otro momento del tiempo existía otro proyecto, tarea o parcial para el que ese momento era de última hora.  Sé que haber dedicado tanto esfuerzo a este proyecto por tanto tiempo es algo que habrá significado para casi todos ustedes un montón de sacrificios tanto académicos como personales, incluyendo la posibilidad de estar al día con el estudio de sus demás materias, salir bien en otras asignaciones de otros cursos, tener cualquier clase de vida social razonable, dormir suficiente para garantizar su salud, poder ir a comer algo bueno en casa del estudiante en vez de comer sopa lipídica de pasta en MYS, etc.  Todos estos sacrificios son apreciados!  Y ahora que al fin se acabó, me gustaría que entendieran algunas de las razones por las que hacer este proyecto no fue una mala inversión de su tiempo, y esto sin siquiera considerar que obtendrán nota.</p>
                <p>Sí: el proyecto fue tedioso y complicado.  No fue particularmente entretenido, y probablemente muchos de ustedes creen que no aprendieron nada interesante haciéndolo; si acaso, les habrá gustado usar Python (al menos a los que no habían trabajado con lenguajes dinámicos similares).  Pero la realidad casi seguramente es todo lo contrario: lo más probable es que este proyecto les haya enseñado muchísimo aunque quizás no estén conscientes de ello.</p>
                <p>Cuando se publicó inicialmente el enunciado, todos pensaban que el proyecto sería sencillo.  El enunciado era bien corto, parecía que Python era un lenguaje muy poderoso que hacía que todo fuera sencillo, y seguro en un par de días de trabajo salía.  Era simplemente cuestión de tomar los argumentos, hacer tal lista, concatenar tal cosa, separar tal caracter... y usando esa misma clase de intuición que han usado para resolver prácticamente todos los proyectos que han hecho en la carrera hasta ahora siguieron avanzando y construyendo ideas cada vez más complejas.  Y ahí, en ese proceso, todos llegaron a un punto donde no podían avanzar más.  Por lo que he visto entre código que vi en consultas y lo que me entregaron, tengo la impresión de que nadie pudo superar las dificultades a las que llegaban al intentar cosas como estas.  Parecía fallar completamente el mecanismo que siempre han sabido aplicar para convertir un enunciado en código que lo implemente.</p>
                <p>La idea del proyecto era, en principio, sencilla: había que construir una expresión regular que reconociera algo.  Eso todos lo han hecho para ejercicios de la teoría, y algunos quizás también lo hayan hecho trabajando con patrones de búsqueda para programas como grep, editores de texto, y quizás hasta aplicaciones directas en programas que hayan escrito (validación de entrada, búsquedas en bases de datos, qué sé yo).  Pero existe una diferencia crucial entre todo eso y lo que tenían que hacer en este proyecto.  Este proyecto puede describirse muy directamente como que dada una especificación de algo en la entrada en un formato particular, debían generar una descripción de exactamente esa misma cosa especificada pero en otro formato.  El primer formato, claro, es el asunto de los argumentos, y el segundo es una expresión regular.  La sintaxis y semántica de los patrones de los argumentos fue especificada en el enunciado, y las de las expresiones regulares era la que define Python.  Lo que tenían que hacer era un programa que tomara cualquiera de las formas de especificar los argumentos y lo convirtiera en una en un elemento del lenguaje de (casi) todas las expresiones regulares de Python, y esa transformación debía preservar el significado de lo que les dieron.</p>
                <p>Creo que en este punto ya deben haber entendido por qué el proyecto en realidad era algo arrechísimo.  Sí: el proyecto podía entenderse como un compilador.  Recibían una especie de código fuente en forma de argumentos de línea de comando, y debían de alguna manera transformar eso en una especie de código de máquina, que en este caso sería una expresión regular, que luego podía ejecutarse sobre una máquina, que en este caso sería la función "match" del módulo "re" de Python.  Y al igual que con cualquier compilador, el significado del programa debe preservarse al pasar por la transformación de código fuente a código de máquina, sea cual sea cada uno de esos lenguajes: la expresión regular que generaban debía ser simplemente una traducción de lo que se especificó en los patrones.  Una traducción que luego se interpreta sobre algo que sepa "ejecutar" expresiones regulares.  Este curso se llama "traductores e interpretadores", y el proyecto que hicieron es una de las asignaciones más simples<a href="#a1"><sup>[1]</sup><a> que se puedan asignar como proyecto y a la vez logren ser un problema que represente el principio fundamental de la materia y de la cadena de lenguajes.</p>
                <p>Lo especial que tuvo este proyecto y que casi seguramente no tuvo ningún otro proyecto que hicieran antes en la carrera es que están generando código.  Lo que siempre se hace es mandarles a resolver un problema y ustedes escriben código a mano para resolver ese problema.  En este proyecto, la entrada en sí era una especificación de un problema, y la salida debía ser código que lo resolviera: una expresión regular apropiada para cada caso.  Aunque de cierta manera cualquier problema abordable por la computación podría en principio representarse como esta clase de correspondencia entre lenguajes, acá esa representación es absolutamente directa.  Resulta, entonces, que el enunciado no contenía una simple especificación de un problema, sino que era una especificación de un lenguaje en el que se pueden especificar problemas, y de cómo ustedes debían escribir un traductor para ese lenguaje.  Podría decirse que todo en esta materia funciona "a nivel <i>meta</i>".  Los que hayan leído todas las tonterías que he escrito en esta página recordarán que alguna vez les mencioné algo sobre documentos de estándares de lenguajes de programación.  Me cito a mí mismo (¡vaya narcisismo!):</p>
                <blockquote><p>Si se lanzan a echarle un ojo a documentos como esos van a descubrir que mucho de lo que creían saber estaba errado y que no saben casi nada de lenguajes y sistemas que creían dominar. Esto es algo bueno: estar conscientes de nuestra propia ignorancia es la mejor manera de evitar que nos joda cuando menos lo esperamos.</p></blockquote>
                <p>Ahora han tenido su primera experiencia con esta clase de documento.  El enunciado dedicó un cuarto de página a describir el lenguaje de entrada (el formato y la interpretación de los argumentos de línea de comando) y otro cuarto de página a los requerimientos sobre implementaciones (a qué lenguaje van a traducir y cómo se debe interpretar).<a href="#a2"><sup>[2]</sup></a>  Sí: toda la dificultad de este proyecto provino de aproximadamente media página de texto.  Es razonable: el lenguaje de entrada es, de hecho, un lenguaje regular, y los lenguajes que describe cada cadena de la entrada (cada forma de dar argumentos de línea de comando) son todos también regulares (porque si no, no hubiera tenido sentido pedirles que las convirtieran en expresiones regulares que expresen lo mismo).  A pesar de esta simplicidad en términos teóricos y de lo corto de la especificación, resultó que había un montón de dudas sobre la interpretación de lo que ahí decía en esa media página:  ¿Qué significa que haya tales y tales patrones?  ¿Qué caracteres pueden llegar en la entrada?  ¿Qué se puede usar del lenguaje al que se traduce?  Todas esas dudas requirieron amplias aclaratorias<a href="#a3"><sup>[3]</sup></a> para permitirles trabajar con la seguridad de que lo que estaban implementando en la traducción correspondería con la semántica especificada para la entrada (los argumentos).</p>
                <p>Consideren, ahora, un lenguaje como C++.  Justo hace un poco menos de un mes se publicó la más reciente versión del nuevo estándar internacional para C++.  Es un documento muy similar al enunciado de su proyecto: especifica en forma precisa el significado de todos los programas válidos en C++, o al menos eso intenta, y también especifica requerimientos sobre las implementaciones de C++: se especifica con precisión cómo debe comportarse cualquier compilador o interpretador de C++ que sea considerado válido según ese estándar internacional.  La diferencia principal entre su enunciado complicado y feo de un cuarto de página y la última versión del estándar internacional para C++ es que este último, en su <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf">último borrador público (en PDF)</a> (que es básicamente idéntico a la versión final publicada), tiene 1334 páginas.  Es tan complejo ese documento que debe ser redactado por muchísimos grupos de trabajo en muchos países, cada uno compuesto por puros expertos en un lenguaje que es tan complejo que les puedo asegurar que no conocen a nadie que entienda bien cómo funciona.  Es tan compleja la especificación de un lenguaje así que, en su primera versión, el lenguaje era ambiguo.  Sí: eso que en las clases de teoría el profesor Novich dice que no debe pasar con ningún lenguaje de programación.  Tranquilos: luego arreglaron eso; mi punto es que las especificaciones de lenguajes de programación pueden llegar a ser tan complejas que ni sus propios creadores puedan darse cuenta de algo tan grave como que no pueda existir una gramática que lo genere y que no sea ambigua, a pesar de que <a href="http://www.open-std.org/jtc1/sc22/wg21/">sus autores</a> son algunos de los mejores expertos existentes en diseño de lenguajes de programación.  Los invito a que lean una que otra entrada en <a href="http://gcc.gnu.org/projects/cxx0x.html">la página del proyecto GCC donde registran sus avances en la implementación del último estándar de C++</a>.  En la tabla que está en esa página está una lista de los cambios que se hicieron al lenguaje, junto con enlaces a los documentos hechos por miembros de los grupos de trabajo de estandarización del lenguaje donde se propone ese cambio particular.  Tomen uno cualquiera y lean el documento, o si no vean directamente <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html">la lista de reportes de defectos del estándar</a>; verán que hay discusiones infinitas sobre lo que debe decir el texto exacto del estándar y las implicaciones de usar tales o cuales palabras.</p>
                <p>A pesar de todo esto, existen varios compiladores de C++ que implementan los estándares, aunque cada compilador lo hace a su manera.  Ustedes ya saben lo difícil que puede ser hacer una interpretación rigurosa de una especificación de un lenguaje, por sencilla que ésta sea.  Podrán imaginarse, entonces, la cantidad de controversias y problemas que aparecen cuando se trata de escribir un compilador tan complejo, y encima si se desea hacerlo compatible con otros compiladores.  Para que esta clase de problema sea tratable existe todo un conjunto de herramientas teóricas y prácticas que son las que se se enseñan y se usan en este curso y en la cadena de lenguajes de programación.  Claro que a estas alturas de su experiencia con estas materias no tienen el conocimiento necesario para resolver este problema de la manera ideal usando un diseño propio de un compilador completo, pero de hecho en la teoría sí se les introdujo una que otra herramienta que es aplicable al problema que debieron resolver: los algoritmos que manipulan directamente las diversas representaciones matemáticas de lenguajes regulares.</p>
                <p>Una manera <strong>segura</strong> de resolver este proyecto hubiera sido implementar una representación en código de autómatas finitos no determinísticos, la transformación de estos a determinísticos, y la transformación de estos últimos a expresiones regulares.  No los estoy regañando por no intentar seguir este camino: ¡es completamente natural que quisieran evitar este trabajo y que intentaran hacer algo directamente con manipulación de strings!  Como les dije antes, tratar de atacar los problemas de computación de frente y por pedacitos, sin mayor uso de abstracciones de la teoría, es lo que les han enseñado a hacer en la mayor parte de la carrera, y en efecto es una buena estrategia para la mayoría de los problemas cotidianos de la computación.  El procesamiento de lenguajes formales, sin embargo, es una familia de problemas que requiere usar directamente un montón de herramientas teóricas para poder resolver los problemas en forma correcta, completa y eficiente.  Es probable que si encontraban un patrón en las expresiones regulares generadas a mano al hacer la manipulación de los autómatas como se tenía que hacer para resolver cada problema de entrada al proyecto, entonces el algoritmo resultante no sería menos complejo que implementar directamente los algoritmos generales de transformación de autómatas, a menos que descubrieran una manera de expresar directamente en el lenguaje de salida (expresiones regulares de Python) la semántica del problema.</p>
                <p>Precisamente eso fue lo que sucedió con algunos de ustedes: resultó que usando ciertas extensiones de Python era posible expresar con extrema sencillez la semántica del problema.  Si usaban esto, el problema se reducía a unas pocas manipulaciones de strings bastante sencillas, aunque no era de ninguna manera trivial.  De las soluciones que recibí y que he revisado, ninguna implementa completa y correctamente la semántica que se especificó; ¡ni siquiera las que usaron lookahead!  Claro, aun me faltan unos cuantos por verificar, así que hay chance. :)  El hecho es que aunque el uso de lookaheads simplificaba mucho lo que tenían que hacer, el método que de ahí salía les proveía muy pocas garantías de que lo que se hacía era lo correcto.  Si implementaban los algoritmos de la teoría podían tener mucha más seguridad, y no iban a depender para nada de funcionalidades extendidas, así que hubieran podido evitar cualquier duda de si el enunciado permitía o no algo que hicieran.</p>
                <p>El problema de si se permitía o no usar lookaheads es algo típico del día a día del trabajo con lenguajes: el enunciado, que es como una especificación de un lenguaje de programación, ponía ciertas restricciones sobre las implementaciones del lenguaje que debían procesar, y la interpretación de esas restricciones es igual de difícil, o hasta más, que escribir una implementación si ya se tiene una interpretación absolutamente clara.  El enunciado decía, y cito,</p>
                <blockquote>
                        <p>El proyecto debe estar implementado usando el lenguaje de programación Python.  Ud. debe implementar el manejo de patrones vía expresiones regulares, tanto para la obtención de los patrones de cada palabra como para realizar la búsqueda.</p>
                        <p>Su proyecto debe correr en las computadoras del LDC, bajo la configuración de dichas máquinas.</p>
                </blockquote>
                <p>Adicionalmente a eso, la página del curso decía</p>
                <blockquote><p>El primer proyecto es relacionado al uso de expresiones regulares POSIX para el desarrollo de un programa que responda consultas sobre un archivo de texto.</p></blockquote>
                <p>Abajo había unos cuantos links a manuales de variedades diversas de expresiones regulares, pero nada que pudiera considerarse parte de una especificación: había referencias tanto a las POSIX básicas como a PCRE, por ejemplo, que más diferentes no podrían ser.  El enunciado especifica claramente que deben generarse "expresiones regulares", pero ¿qué significa esto exactamente?  En la teoría del curso, las expresiones regulares tienen como símbolos especiales el '(', el ')', el '+' y el '*'; más nada.  Hacer el proyecto con únicamente estos elementos no hubiera sido viable por una sencilla razón: es necesario usar un montón de cosas en la expresión regular que dicen "cualquier símbolo que no sea alguno de estos", y expresar eso hubiera sido ridículamente feo si se limitaban a esas funcionalidades tan básicas de las expresiones regulares.  Hasta en el supuesto de que el juego de caracteres a soportar hubiera sido sencillamente ASCII, o solo el alfabeto en minúsculas, no es razonable que una entrada tan sencilla como "-a" generara una salida tan horrible como cada uno de los caracteres del alfabeto excepto la 'a' unidos con '+' (y luego un asterisco, por ejemplo).  Además que la sintaxis exacta a usar no podría haber sido precisamente la misma porque el módulo "re" de Python usa el símbolo "+" para representar algo que nada tiene que ver con alternativas ni unión de lenguajes.  Hay un montón de otras formas de interpretar lo que se tenía que hacer, pero en sí siempre se habló de usar las funcionalidades proveidas por Python para reconocer expresiones regulares, y resulta que Python tiene un módulo que dice que trabaja con "expresiones regulares", así que habría que usarlo, no?</p>
                <p>El detalle está en que lo que Python llama "expresiones regulares" no tiene un coño de regular, y pasa lo mismo con los estándares POSIX (que, por cierto, también requieren <a href="http://standards.ieee.org/findstds/interps/1003-2-92_int/index.html">documentos con aclaratorias de interpretación</a>).  Tanto las "expresiones regulares" básicas como las extendidas especificadas por POSIX, así como las que procesa el módulo "re" de Python, soportan cosas que hacen que sea posible reconocer lenguajes sensibles al contexto que no son lenguajes regulares: los backreferences.  Podía pensarse, entonces, que si usaban algo raro que tuvieran estas expresiones supuestamente regulares, entonces ya los lenguajes que reconocían ya no serían necesariamente regulares y por lo tanto violarían una cierta interpretación de la especificación que exige que se trabaje con algo que en el curso se llama "expresiones regulares".  Por eso desde el comienzo, en la primerita clase práctica que di, hablé sobre lo que pueden expresar los diversos sistemas que se llaman a sí mismos sistemas de expresiones regulares, y aclaré que lo que se usaría en este curso es lo que permita expresar todos los lenguajes regulares, y únicamente lenguajes regulares.  También hablé sobre eso en el primer mensaje que puse en esta página.  No fui el único encargado de práctica que hizo esto.  Entre nuestros comentarios y mis publicaciones sería en principio suficiente para especificar con precisión qué es lo que no podrían usar: cualquier cosa que expanda el poder expresivo del sistema que usaban a algo más que lenguajes regulares.</p>
                <p>Luego llegó la hora de publicar aclaratorias, porque, claro, había detalles implícitos en los requerimientos que no estaban completamente claros.  Las aclaratorias, que fueron publicadas después que el enunciado, no podían exigir nada que no estuviera ya implícito en el enunciado original o en otras publicaciones relacionadas con el curso y que existieran en el momento en que fue publicado el enunciado: si alguna cosa en el contenido de las aclaratorias hubiera añadido requerimientos al proyecto que no hubieran estado implícita o explícitamente expresados en esos materiales, se estaría rompiendo el contrato entre profesores y estudiantes que representa la publicación de un enunciado.  Afortunadamente, no fue así: no hay ni una sola palabra en las aclaratorias que contradiga o expanda lo que estaba dicho en el enunciado y en la página oficial del curso (hasta donde yo sé).  Yo personalmente escribí el texto de las aclaratorias con mucho cuidado para que esto fuera así.</p>
                <p>Pero entonces, dirán ustedes, ¿qué hay del asunto de las extensiones de Python?  ¿Se podían usar o no?  Veamos lo que dice el texto de las aclaratorias en la sección relevante:</p>
                <blockquote>
                <p>Las funcionalidades de las expresiones regulares del módulo "re" de Python que podrán usar son las directamente equivalentes a funcionalidades ofrecidas por las expresiones regulares básicas especificadas por el estándar POSIX.2, añadiendo la alternación (especificada por '\|' en las expresiones regulares básicas de POSIX y por '|' en Python).  Para la implementación del proyecto solo es estrictamente necesario el uso de parentización ('(' y ')'), alternación ('|'), concatenación (implícita), la estrella ('*') y las clases de caracteres (mediante '[', ']' y otros caracteres involucrados con estos objetos).  Para su comodidad, podrían también usar, si así lo desean, los operadores '+', '?', la repetición (mediante '{', ',' y '}'), el '.', las anclas '^', '$', "\A", "\Z", y el caracter de escape '\'.  En particular, no podrán usar operadores especiales de las expresiones regulares de Python que hagan que reconozcan lenguajes que no sean regulares.  La documentación de Python describe en detalle la forma de especificar expresiones regulares con el módulo "re".</p>
                </blockquote>
                <p>Si hacen una lectura estricta de lo que dice ahí, que es lo que deben hacer siempre que lean un documento de especificación de cualquier cosa, hay varios problemas de interpretación.  Primero se dice que pueden usar cualquier cosa equivalente a lo que ofrecen las BREs de POSIX, junto con la alternación.  ¡Pero eso incluye backreferences!  Además, se utiliza la frase "directamente equivalentes".  ¿Qué significa que dos cosas sean "directamente equivalentes"?  Los conceptos de equivalencia usados en las clases de teoría definen claramente el concepto de equivalencia de lenguajes: igualdad de conjuntos.  Acá las cosas no son tan claras.  Sin embargo, hay dos cosas más adelante que indican más claramente lo que deben y no deben hacer: al decir que "no podrán usar operadores especiales de las expresiones regulares de Python que hagan que reconozcan lenguajes que no sean regulares" se excluyen en forma clara y precisa, al menos, los backreferences.  Pero ¿qué más se excluye al decir eso?  ¿Es razonable pensar que el uso de la frase "en particular" implica que esa no es una lista exhaustiva de cosas excluidas, sino apenas un ejemplo?  Y si se usa tan liberalmente la frase "expresiones regulares" a pesar de que el término signifique cosas diferentes en tantos contextos, ¿cómo debe interpretarse esta aclaratoria?</p>
                <p>Mi interpretación de la documentación autoritativa para el proyecto (la página del curso en el estado que tenía al momento de la publicación del enunciado, y el texto del enunciado en sí) es que el proyecto debía generar una cadena de caracteres que cumpliera dos condiciones:</p>
                <ul>
                        <li><p>Que pueda ser pasada como primer argumento a la función "match" del módulo "re" de Python, ejecutada con las líneas de los archivos de entrada, una a la vez, en el segundo argumento, y se retornara un objeto diferente a "None" si y solo si esa línea debía ser aceptada por la especificación de patrones en los parámetros de línea de comando que fueron usados para construir la cadena de caracteres en cuestión, y</p></li>
                        <li><p>que existiera un algoritmo para transformar esa cadena de caracteres en una expresión regular matemática como las de la teoría de forma tal que el lenguaje especificado por esa expresión regular contenga exactamente las cadenas que deben ser aceptadas/reconocidas/mostradas por el programa en caso de aparecer como una línea en un archivo de entrada.</p></li>
                </ul>
                <p>La segunda condición asegura que todo lo que escribamos pueda representarse de manera exactamente igual usando expresiones regulares de la teoría, así que nos obliga a quedarnos dentro de los lenguajes regulares.  ¿Podemos, entonces, usar lookaheads?  En StackOverflow hay una <a href="http://stackoverflow.com/questions/2974210/does-lookaround-affect-which-languages-can-be-matched-by-regular-expressions">pregunta</a> sobre si los lookaheads extienden el poder expresivo de las expresiones regulares a algo que no sea lenguajes regulares.  La primera respuesta que aparece explica cómo demostrar que las expresiones regulares normales con la adición de lookahead positivo pueden ser transformadas en una clase especial de autómata finito que resulta ser equivalente a los autómatas finitos determinísticos, y es bastante obvio ver cómo se haría la misma construcción para lookahead negativo.  También se incluye en esa respuesta un enlace a un paper donde se define esta nueva clase de autómata y se demuestra, entre un montón de otras cosas interesantísimas, que son equivalentes a autómatas finitos determinísticos: tienen exactamente el mismo poder expresivo en términos de los lenguajes que generan (aunque con diferencias fascinantes en la forma en que los reconocen, el tamaño de los autómatas para un mismo lenguaje, etc).  Usando esta información, pueden defender haber tomado la decisión, como implementadores de un lenguaje de acuerdo a una especificación, que su implementación respeta todo lo que se especificó.  Al final lo importante es entender lo que hicieron suficientemente bien como para poder defender esa aserción que está implícita cuando envían una entrega.</p>
                <p>Si esta es la mentalidad que tuvieron al abordar el proyecto, entonces su asignación habrá sido todo un éxito.  Es extremadamente difícil escribir especificaciones como estas de una forma que no sea totalmente ambigua, y al final deben hacer el mejor esfuerzo posible por tomar una interpretación razonable de las pautas autoritativas, valga la redundancia, y con esa interpretación implementar algo razonablemente útil, consistente y funcional.  El objetivo del proyecto, más allá de ser simplemente implementar el problema que se especificó, era lograr que desarrollaran esta clase de pensamiento lógico, crítico, analista y cuestionador.  El enunciado del segundo proyecto del curso consistirá de una especificación, también en lenguaje natural, de un lenguaje de programación capaz de computar cualquier cosa que pueda ser computada, y habrá ciertos detalles sintácticos, semánticos y de restricciones de implementación que estarán sujetos a toda clase de interpretaciones posiblemente contradictorias como en efecto sucedió en el caso de este pequeño proyecto de media página.  Prepárense.  Van a tener que leer con muchísima dedicación cada palabra de cada frase del enunciado y determinar tan bien como puedan cuál es el concepto que se desea definir de forma estandarizada para que todas las implementaciones de todos los grupos sean tan compatibles como sea posible con el estándar y entre sí.  Esto es lo que hacen quienes se dedican a escribir traductores e interpretadores para lenguajes definidos por documentos de estandarización, como C, C++, Haskell, Lisp<a href="#a4"><sub>[4]</sub></a>, Prolog, Pascal, JavaScript<a href="#a5"><sub>[5]</sub></a>, HTML, XML, SGML, CSS, VHDl y probablemente cientos de lenguajes más, algunos usados para programación, otros para descripción de documentos, otros para descripción de hardware, otros para descripción de escenas (piensen en computación gráfica), y cualquier otra cosa que se puedan imaginar.  Otros lenguajes no utilizan documentos de estandarización, sino que existe una implementación considerada canónoca que se toma como referencia; es el caso de Java, JavaScript (sí: está en las dos listas; sí: es un desastre), Python, Ruby, y muchísimos otros.  Busquen la frase "reference implementation" en Google para que se hagan una idea de lo diversos que pueden ser los lenguajes que usan esta técnica de estandarización.  Estas metodologías de trabajo, sus problemas y sus resultados, que son parte fundamental de lo que hace posible que suceda absolutamente todo lo que hacen sus computadoras, son lo que nos interesa estudiar en este curso, en el de lenguajes de programación, y en la cadena de lenguajes.  ¡Bienvenidos al maravilloso mundo de los lenguajes de programación!</p>
                <p>Dicho eso, no le agarren rabia a las expresiones regulares solo porque haya sido difícil trabajar con ellas; las expresiones regulares son herramientas maravillosas para toda clase de tareas manuales y automatizadas que nosotros, los computistas, hacemos a diario.  Son extremadamente útiles para edición y búsquedas en texto, que es lo que hacemos la mayor parte del tiempo que dedicamos a programar, y aprender a usarlas cotidianamente para editar código es algo que podría hacerlos programar muchísimo más rápido y mejor.  También son extremadamente útiles para escribir en general: ya he usado unas cuantas en la edición del texto que están leyendo ahora mismo.  La dificultad de este proyecto emana de que debían generar expresiones regulares automáticamente; generar código siempre será un problema difícil, sea cual sea la clase de código que van a generar.  Cuando escriben expresiones a mano, como hacen en la teoría, por ejemplo, no es algo tan complicado.  En cualquier caso, no paguen su arrechera destruyendo casas ni matando sapos.</p>
                <hr/>
                <p>Notas:</p>
                <ol>
                        <li id="a1"><p>"simple" de ninguna manera implica "fácil"</p></li>
                        <li id="a2"><p>Casi todo lo que escribí ignora la presencia del asunto de leer los archivos como tal y correr el match en cada línea.  Realmente esa parte del proyecto era absolutamente trivial y lo importante era crear la expresión regular, así que es razonable ignorar esa parte del proyecto.</p></li>
                        <li id="a3"><p>Meta-aclaratoria: no contienen ni una pisca de información que no estuviera explícita o implícita en la combinación de la página del curso y el enunciado</p></li>
                        <li id="a4"><p>Lisp es una familia de lenguajes bastante diversa, y sus dialectos pueden estar definidos por estándares, por implementaciones de referencia, o pueden estar asociados directamente a implementaciones particulares (y la distinción entre los dos últimos casos es algo bastante difícil de definir, claro).</p></li>
                        <li name="a5"><p>De hecho la familia de lenguajes referida comúnmente por el término "JavaScript" es un excelente ejemplo de un fracazo catastrófico en los intentos de estandarización, y esto ha tenido consecuencias nefastas para el desarrollo de tecnologías web.</p></li>
                </ol>
                <hr/>
                <p>
                        <a href="http://validator.w3.org/check?uri=referer">
                                <img src="http://www.w3.org/Icons/valid-xhtml11" alt="Valid XHTML 1.1" height="31" width="88"/>
                        </a>
                </p>
                <p>Y lo escribí a mano en Vim sin más referencia que las primeras 4 líneas del boilerplate.</p>
                <p>Like a boss.</p>
        </body>
</html>
